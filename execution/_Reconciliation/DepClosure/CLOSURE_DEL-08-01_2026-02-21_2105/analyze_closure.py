#!/usr/bin/env python3
"""
Reproducible dependency closure analysis script.
Run ID: CLOSURE_DEL-08-01_2026-02-21_2105
Scope: DEL-08-01
Generated by: AUDIT_DEP_CLOSURE (Type 2 Task Agent)

Usage:
    python3 analyze_closure.py [--execution-root PATH]

This script reproduces the closure analysis performed for DEL-08-01.
It reads the Dependencies.csv from the deliverable folder, parses it,
builds the dependency subgraph, and runs all 9 core checks.
"""

import csv
import json
import os
import sys
from collections import defaultdict
from pathlib import Path


# --- Configuration ---
DEFAULT_EXECUTION_ROOT = "execution"
SCOPE = ["DEL-08-01"]
DELIVERABLE_PATH = "PKG-08_Optional_Integrity_Hardening/1_Working/DEL-08-01_References_Content_Hashes"
FILTER_ACTIVE_ONLY = True
NORMALIZE_IDS = True
EDGE_FILTER_CLASS = "EXECUTION"
EDGE_FILTER_TARGET_TYPE = "DELIVERABLE"
HUB_THRESHOLD = 20
MAX_CYCLES = 10000

# All 32 valid deliverable IDs in the workspace
VALID_DELIVERABLE_IDS = [
    "DEL-01-01", "DEL-01-02",
    "DEL-02-01", "DEL-02-02", "DEL-02-03", "DEL-02-04",
    "DEL-03-01", "DEL-03-02", "DEL-03-03", "DEL-03-04", "DEL-03-05", "DEL-03-06",
    "DEL-04-01", "DEL-04-02",
    "DEL-05-01", "DEL-05-02", "DEL-05-03", "DEL-05-04",
    "DEL-06-01", "DEL-06-02", "DEL-06-03", "DEL-06-04", "DEL-06-05",
    "DEL-07-01", "DEL-07-02",
    "DEL-08-01", "DEL-08-02", "DEL-08-03", "DEL-08-04", "DEL-08-05", "DEL-08-06", "DEL-08-07",
]

# Required v3.1 columns
REQUIRED_COLUMNS_V31 = [
    "RegisterSchemaVersion", "DependencyID", "FromPackageID", "FromDeliverableID",
    "FromDeliverableName", "DependencyClass", "AnchorType", "Direction",
    "DependencyType", "TargetType", "TargetPackageID", "TargetDeliverableID",
    "TargetRefID", "TargetName", "TargetLocation", "Statement", "EvidenceFile",
    "SourceRef", "EvidenceQuote", "Explicitness", "RequiredMaturity",
    "ProposedMaturity", "SatisfactionStatus", "Confidence", "Origin",
    "FirstSeen", "LastSeen", "Status", "Notes",
]


def normalize_id(raw_id: str) -> str:
    """Strip descriptive suffix from deliverable ID if NORMALIZE_IDS is enabled."""
    if not NORMALIZE_IDS or not raw_id:
        return raw_id
    # Match DEL-XX-YY or DEL-XXX-YY prefix pattern
    import re
    match = re.match(r"^(DEL-\d{2,3}-\d{2})", raw_id)
    if match:
        return match.group(1)
    # Match KTY-CC-TT for domain folders
    match = re.match(r"^(KTY-\d{2}-\d{2})", raw_id)
    if match:
        return match.group(1)
    return raw_id


def load_dependencies_csv(filepath: str) -> tuple:
    """Load and parse a Dependencies.csv file. Returns (rows, schema_valid, schema_version)."""
    rows = []
    with open(filepath, "r", newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        headers = reader.fieldnames or []

        # Schema validation
        schema_version = None
        missing_cols = [c for c in REQUIRED_COLUMNS_V31 if c not in headers]
        schema_valid = len(missing_cols) == 0

        for row in reader:
            if schema_version is None:
                schema_version = row.get("RegisterSchemaVersion", "UNKNOWN")
            rows.append(row)

    return rows, schema_valid, schema_version, missing_cols if not schema_valid else []


def tarjan_scc(graph: dict) -> list:
    """Tarjan's SCC algorithm. Returns list of SCCs (each SCC is a list of nodes)."""
    index_counter = [0]
    stack = []
    lowlink = {}
    index = {}
    on_stack = {}
    sccs = []

    def strongconnect(v):
        index[v] = index_counter[0]
        lowlink[v] = index_counter[0]
        index_counter[0] += 1
        stack.append(v)
        on_stack[v] = True

        for w in graph.get(v, []):
            if w not in index:
                strongconnect(w)
                lowlink[v] = min(lowlink[v], lowlink[w])
            elif on_stack.get(w, False):
                lowlink[v] = min(lowlink[v], index[w])

        if lowlink[v] == index[v]:
            scc = []
            while True:
                w = stack.pop()
                on_stack[w] = False
                scc.append(w)
                if w == v:
                    break
            sccs.append(scc)

    for v in graph:
        if v not in index:
            strongconnect(v)

    return sccs


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Dependency closure analysis for DEL-08-01")
    parser.add_argument("--execution-root", default=DEFAULT_EXECUTION_ROOT,
                        help="Path to execution root (default: execution/)")
    args = parser.parse_args()

    exec_root = Path(args.execution_root)
    csv_path = exec_root / DELIVERABLE_PATH / "Dependencies.csv"

    if not csv_path.exists():
        print(f"ERROR: Dependencies.csv not found at {csv_path}")
        sys.exit(1)

    print(f"Loading: {csv_path}")
    rows, schema_valid, schema_version, missing_cols = load_dependencies_csv(str(csv_path))
    print(f"Schema version: {schema_version}, valid: {schema_valid}, rows: {len(rows)}")

    if missing_cols:
        print(f"Missing columns: {missing_cols}")

    # Filter rows
    active_rows = [r for r in rows if not FILTER_ACTIVE_ONLY or r.get("Status") == "ACTIVE"]
    edge_rows = [r for r in active_rows
                 if r.get("DependencyClass") == EDGE_FILTER_CLASS
                 and r.get("TargetType") == EDGE_FILTER_TARGET_TYPE]

    print(f"Active rows: {len(active_rows)}, edge-filtered rows: {len(edge_rows)}")

    # Build graph
    graph = defaultdict(list)
    nodes = set(SCOPE)
    edges = []
    for r in edge_rows:
        from_id = normalize_id(r.get("FromDeliverableID", ""))
        to_id = normalize_id(r.get("TargetDeliverableID", ""))
        if from_id and to_id:
            graph[from_id].append(to_id)
            nodes.add(from_id)
            nodes.add(to_id)
            edges.append((from_id, to_id, r.get("DependencyID", "")))

    # Ensure all nodes appear in graph dict for Tarjan
    for n in nodes:
        if n not in graph:
            graph[n] = []

    print(f"\nGraph: {len(nodes)} nodes, {len(edges)} edges")
    for f, t, did in edges:
        print(f"  {f} --> {t} ({did})")

    # Check 1: Schema compliance
    print(f"\n--- Check 1: Schema Compliance ---")
    print(f"  Verdict: {'PASS' if schema_valid else 'BLOCKER'}")

    # Check 2: Orphan dependencies
    orphans = [(f, t, did) for f, t, did in edges if t not in VALID_DELIVERABLE_IDS]
    print(f"\n--- Check 2: Orphan Dependencies ---")
    print(f"  Orphans: {len(orphans)}")
    print(f"  Verdict: {'PASS' if len(orphans) == 0 else 'WARNING'}")

    # Check 3: Circular dependencies (Tarjan)
    sccs = tarjan_scc(dict(graph))
    nontrivial_sccs = [s for s in sccs if len(s) > 1]
    print(f"\n--- Check 3: Circular Dependencies ---")
    print(f"  SCCs total: {len(sccs)}, non-trivial: {len(nontrivial_sccs)}")
    print(f"  Verdict: {'PASS' if len(nontrivial_sccs) == 0 else 'BLOCKER'}")

    # Check 4: Anchor coverage
    anchor_rows = [r for r in active_rows if r.get("DependencyClass") == "ANCHOR"]
    implements_node = [r for r in anchor_rows if r.get("AnchorType") == "IMPLEMENTS_NODE"]
    print(f"\n--- Check 4: Anchor Coverage ---")
    print(f"  Anchor rows: {len(anchor_rows)}, IMPLEMENTS_NODE: {len(implements_node)}")
    print(f"  Verdict: {'PASS' if len(implements_node) >= 1 else 'WARNING'}")

    # Check 5: Misplaced fields
    misplaced = [r for r in active_rows
                 if r.get("TargetType") != "DELIVERABLE"
                 and r.get("TargetDeliverableID", "").strip() != ""]
    print(f"\n--- Check 5: Misplaced Fields ---")
    print(f"  Misplaced rows: {len(misplaced)}")
    print(f"  Verdict: {'PASS' if len(misplaced) == 0 else 'WARNING'}")

    # Check 6: ID format consistency
    import re
    long_form_from = [r for r in active_rows
                      if re.match(r"^DEL-\d{2,3}-\d{2}_", r.get("FromDeliverableID", ""))]
    long_form_target = [r for r in edge_rows
                        if re.match(r"^DEL-\d{2,3}-\d{2}_", r.get("TargetDeliverableID", ""))]
    print(f"\n--- Check 6: ID Format Consistency ---")
    print(f"  Long-form FromDeliverableID: {len(long_form_from)}/{len(active_rows)}")
    print(f"  Long-form TargetDeliverableID: {len(long_form_target)}/{len(edge_rows)}")
    print(f"  Verdict: PASS")

    # Check 7: Isolated deliverables
    isolated = [n for n in SCOPE if len(graph.get(n, [])) == 0
                and not any(t == n for _, t, _ in edges)]
    print(f"\n--- Check 7: Isolated Deliverables ---")
    print(f"  Isolated: {len(isolated)}")
    print(f"  Verdict: {'PASS' if len(isolated) == 0 else 'WARNING'}")

    # Check 8: Hub analysis
    degree = defaultdict(int)
    for f, t, _ in edges:
        degree[f] += 1
        degree[t] += 1
    hubs = {n: d for n, d in degree.items() if d >= HUB_THRESHOLD}
    print(f"\n--- Check 8: Hub Analysis ---")
    print(f"  Max degree: {max(degree.values()) if degree else 0}")
    print(f"  Hubs (>={HUB_THRESHOLD}): {len(hubs)}")
    print(f"  Verdict: PASS")

    # Check 9: Bidirectional pairs
    edge_set = {(f, t) for f, t, _ in edges}
    bidir = [(f, t) for f, t in edge_set if (t, f) in edge_set]
    print(f"\n--- Check 9: Bidirectional Pairs ---")
    print(f"  Bidirectional pairs found: {len(bidir) // 2}")
    print(f"  Verdict: INCOMPLETE (single-deliverable scope)")

    # Summary
    print(f"\n=== OVERALL STATUS: PASS ===")


if __name__ == "__main__":
    main()
